#Please refer to the picture in the unnamed.pdf

鄰接矩陣(行/列)對調，若能達到一致，則保證同構

想法:若同構，在矩陣關係上，彼此只有編號順序不同而已

  a,b,c,d,e,f,g,h,i,j
  0 1 0 0 1 1 0 0 0 0
  1 0 1 0 0 0 1 0 0 0
  0 1 0 1 0 0 0 1 0 0*
  0 0 1 0 1 0 0 0 1 0
  1 0 0 1 0 0 0 0 0 1
  1 0 0 0 0 0 0 1 1 0
  0 1 0 0 0 0 0 0 1 1*
  0 0 1 0 0 1 0 0 0 1
  0 0 0 1 0 1 1 0 0 0
  0 0 0 0 1 0 1 1 0 0

=>將上述轉視為二進制碼檢查兩個圖是否有一樣的數字 (利用XOR)
  ，兩集合之組成相同，則為同構
   ("*" 表示首次檢查相同者)
=>針對兩集合之XOR部分(union(A-B,B-A))，進行column對調(*row對調也可以)
  若能順利對調完成，則同構
=>在對調row之前，需針對"*"的部分檢查對調後是否受影響，不影響才能對調
   (...0....1...或...1....0...會受影響)
   若對調後，針對union(A,B)的部分，做記號(*)

  k,l,m,n,o,p,q,r,s,t
k 0 1 0 0 0 0 0 0 1 1*
l 1 0 1 0 0 1 0 0 0 0
m 0 1 0 1 0 0 0 1 0 0*
n 0 0 1 0 1 0 0 0 0 1
o 0 0 0 1 0 1 0 0 1 0
p 0 1 0 0 1 0 1 0 0 0
q 0 0 0 0 0 1 0 1 0 1
r 0 0 1 0 0 0 1 0 1 0
s 1 0 0 0 1 0 0 1 0 0
t 1 0 0 1 0 0 1 0 0 0

A row(3,7)=B row(1,3)

swap(p,q)不影響row(1,3) => A row(1,2,3,7)=B row(6,2,3,1)
	*p,q對調，意味可能因此符合f,g = 1,0(或0,1)的row

swap(s,t)不影響B row(1,2,3,6) => A row(1,2,3,4,7)=B row(6,2,3,4,1)

swap(k,p)不影響B row(1,2,3,4,6) => A row(1,2,3,4,5,6,7,8,9,10)=B row(6,2,3,4,5,7,1,8,10,9)
	*k,p對調，意味可能因此符合a,f = 1,0(或0,1)的row
=>
  p,l,m,n,o,q,k,r,t,s
k 0 1 0 0 0 0 0 0 1 1
l 1 0 1 0 0 0 1 0 0 0
m 0 1 0 1 0 0 0 1 0 0
n 0 0 1 0 1 0 0 0 1 0
o 1 0 0 1 0 0 0 0 0 1
p 0 1 0 0 1 1 0 0 0 0
q 1 0 0 0 0 0 0 1 1 0
r 0 0 1 0 0 1 0 0 0 1
s 0 0 0 0 1 0 1 1 0 0
t 0 0 0 1 0 1 1 0 0 0
=>
A(a,b,c,d,e,f,g,h,i,j) =
B(p,l,m,n,o,q,k,r,t,s)


對映方式不唯一 <= 對調方式不唯一
  k,l,m,n,t,s,p,r,o,q
k 0 1 0 0 1 1 0 0 0 0
l 1 0 1 0 0 0 1 0 0 0
m 0 1 0 1 0 0 0 1 0 0
n 0 0 1 0 1 0 0 0 1 0
o 0 0 0 1 0 1 1 0 0 0
p 0 1 0 0 0 0 0 0 1 1
q 0 0 0 0 1 0 1 1 0 0
r 0 0 1 0 0 1 0 0 0 1
s 1 0 0 0 0 0 0 1 1 0
t 1 0 0 1 0 0 0 0 0 1

conclusion:
A(a) = k
A(b) = l
A(c) = m
A(d) = n
A(e) = t
A(f) = s
A(g) = p
A(h) = r
A(i) = o
A(j) = q
*節點少時，直接由肉眼判斷較關係矩陣快
 但若要交給程式執行，使用關係矩陣很方便




